{"version":"1","records":[{"hierarchy":{"lvl1":"Programmering for l√¶rere"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Programmering for l√¶rere"},"content":"P√• denne nettsiden vil vi etterhvert legge ut aktiviteter og opplegg som handler om programmering i skolen.\n\nDisse nettsidene er ikke ment som kurs i grunnleggende programmering, men heller som en samling av kortere eller lengre eksempler p√• hvordan programmering kan brukes til undervisning og utforsking i matematikk og naturfag\n\nAv:\n\nViggo T. Andresen - USN\n\nSigurd Rage - USN","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Matematikk - introduksjon"},"type":"lvl1","url":"/matematikk-oversikt","position":0},{"hierarchy":{"lvl1":"Matematikk - introduksjon"},"content":"Innledende tekst om denne delen av nettsiden","type":"content","url":"/matematikk-oversikt","position":1},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no"},"type":"lvl1","url":"/mattespill-kidsakoder","position":0},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no"},"content":"Forfatter: Geir Arne Hjelle\n\nUrl: \n\nhttps://‚Äãoppgaver‚Äã.kidsakoder‚Äã.no‚Äã/python‚Äã/mattespill‚Äã/mattespill\n\nOmskrevet til Jupyter Notebook av Sigurd Rage USN\n\n","type":"content","url":"/mattespill-kidsakoder","position":1},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Introduksjon"},"type":"lvl2","url":"/mattespill-kidsakoder#introduksjon","position":2},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Introduksjon"},"content":"\n\nI denne leksjonen vil vi se litt n√¶rmere p√• hvordan Python jobber med tall, og vi vil lage et enkelt mattespill. Vi vil ogs√• se hvordan vi kan gj√∏re ting tilfeldige.\n\nForutsetter kjennskap til print-funksjonen, variabler, if-tester og for-sl√∏yfer.\n\n","type":"content","url":"/mattespill-kidsakoder#introduksjon","position":3},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 1: De fire regneartene"},"type":"lvl2","url":"/mattespill-kidsakoder#steg-1-de-fire-regneartene","position":4},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 1: De fire regneartene"},"content":"\n\nPython er, som de fleste programmeringsspr√•k, veldig glad i √• regne. La oss se hvordan vi kan f√• Python til √• regne for oss.\n\nVi begynner med √• utforske hvordan vi kan bruke Python til √• regne ut enkle mattestykker. Kj√∏r koden under!\n\n4/2\n\nN√•r programmet kj√∏rer vil det skrive ut 4 tall. Kjenner du igjen disse tallene? Skj√∏nner du hva symbolene * og / betyr? Endre gjerne p√• programmet og kj√∏r det flere ganger til du skj√∏nner hvordan Python bruker pluss, minus, gange og dele.\n\n","type":"content","url":"/mattespill-kidsakoder#steg-1-de-fire-regneartene","position":5},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 2: Vi kaster terning"},"type":"lvl2","url":"/mattespill-kidsakoder#steg-2-vi-kaster-terning","position":6},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 2: Vi kaster terning"},"content":"\n\nFor √• lage et mattespill vil vi bruke tilfeldige tall. Tilfeldige tall blir omtrent som √• sl√• terning for √• finne et tall.\n\nFor √• lage tilfeldige tall skal vi bruke en ny Python-funksjon som heter randint (her er rand en forkortelse for random som betyr tilfeldig, og int en forkortelse for integer som betyr heltall). Denne funksjonen er ikke med i grunnpakken til Python, men ligger i stedet i et bibliotek kalt random. Vi m√• derfor fortelle Python at vi vil bruke dette biblioteket. I biblioteket f√∏lger det med mange forskjellige funksjoner for √• generer tilfeldige tall, vi skal bruke funksjonen randint.\n\nimport random\nprint(random.randint(1, 6))\n\nN√•r du kj√∏rer programmet vil det skrive ut et tilfeldig tall mellom 1 og 6. Kj√∏r programmet flere ganger. Forandrer tallet seg?\n\nPr√∏v selv √• forandre programmet slik at det skriver ut tilfeldige tall mellom 1 og 20! Eller mellom -1 og 1.\n\nProgrammet viser hvordan vi kan late som om vi sl√•r √®n terning i Python. Men hvordan kan vi late som om vi sl√•r to terninger, og ser summen av dem?\n\nVi kan ogs√• utvide programmet slik at det sl√•r terning mange ganger. Dette gj√∏r vi enklest med for-l√∏kker. Hvis du for eksempel utvider programmet ditt som f√∏lger vil det se ut som om du sl√•r to terninger 25 ganger:\n\nimport random\n\nfor i in range(25):\n    print(random.randint(1, 6) + random.randint(1, 6))\n\n","type":"content","url":"/mattespill-kidsakoder#steg-2-vi-kaster-terning","position":7},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 3: En liten mattepr√∏ve"},"type":"lvl2","url":"/mattespill-kidsakoder#steg-3-en-liten-mattepr-ve","position":8},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 3: En liten mattepr√∏ve"},"content":"\n\nVi kan n√• bruke tilfeldige tall til √• lage et enkelt mattespill. Vi begynner med √• trekke to tilfeldige tall, og la Python gange dem sammen:\n\nimport random\n\ntall1 = random.randint(2, 12)\ntall2 = random.randint(2, 12)\n\nprint(tall1)\nprint(tall2)\n\n\nVi vil n√• at Python skal gi oss en matteoppgave, kan vi bli spurt om √• gange sammen tall1 og tall2? Vi legger til f√∏lgende kode. Hva skjer n√•r du pr√∏ver √• kj√∏re programmet?\n\nprint('Hva er ' + str(tall1) + ' ganger ' + str(tall2) + '?')\n\nI kodesnutten over f√•r vi en feilmelding og programmet stopper. Dette M√Ö fikses f√∏r vi kan g√• videre i eksemplene under. Du husker kanskje at vi kan bruke + for √• sette sammen tekst? Men vi bruker ogs√• + for √• plusse sammen tall. I linjen over pr√∏ver vi √• bruke + p√• b√•de tekst og tall, og da skj√∏nner ikke Python helt hva vi mener.\n\nFor √• fortelle Python at her vil vi egentlig sette sammen tekst m√• vi bruke funksjonen str for √• gj√∏re om tallene til tekst (str er en forkortelse for streng, som er det vi kaller tekster p√• fagspr√•ket). Endre den siste linjen slik at den ser slik ut i stedet, og kj√∏r p√• nytt:\n\nprint('Hva er ‚Äô + str(tall1) + ‚Äô ganger ‚Äô + str(tall2) + ‚Äò?‚Äô)\n\nVirker programmet ditt bedre n√•? Pr√∏v √• kj√∏re programmet flere ganger. Blir du stilt forskjellige sp√∏rsm√•l?\n\nNeste steg er at vi vil kunne svare p√• mattestykket. Til dette bruker vi igjen funksjonen input. Se f√∏lgende kode:\n\nsvar = input()\n\nprint(svar)\n\nLegg merke til at programmet n√• venter p√• at du skal skrive inn et svar i tekstfeltet\n\nVi skal n√• f√• programmet til √• sjekke at vi har svart riktig. For √• gj√∏re dette skal vi bruke noe som heter if-tester. Disse kan sjekke om noe er sant, og vi vil bruke dem for √• sjekke om det er sant at svaret ditt er likt med det faktiske svaret. Vi legger til en if-test nederst i programmet ditt slik som dette:\n\nimport random\n\ntall1 = random.randint(2, 12)\ntall2 = random.randint(2, 12)\n\nprint('Hva er ' + str(tall1) + ' ganger ' + str(tall2) + '?')\nsvar = input()\nsvar = int(svar)\n\n\n\nif svar == tall1 * tall2:\n    print('Ja, svaret er ' + str(svar))\nelse:\n    print('Nei, det riktige svaret er ' + str(tall1 * tall2))\n\nPass p√• at som i for-l√∏kker m√• du skyve koden i if-testen inn mot h√∏yre.\n\nKj√∏r programmet ditt med forskjellige svar. Virker det? Hva skjer om du svarer feil p√• en oppgave? Hva skjer om du svarer riktig?\n\nHmm ... det er et problem med programmet v√•rt. Programmet sier at vi svarer feil selv om vi svarer riktig!\n\n","type":"content","url":"/mattespill-kidsakoder#steg-3-en-liten-mattepr-ve","position":9},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl3":"Bug","lvl2":"Steg 3: En liten mattepr√∏ve"},"type":"lvl3","url":"/mattespill-kidsakoder#bug","position":10},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl3":"Bug","lvl2":"Steg 3: En liten mattepr√∏ve"},"content":"\n\nDette er et eksempel p√• noe vi kaller en bug i et program. Programmet kj√∏rer, men det gj√∏r ikke slik som vi hadde ment og forventet. Selve ordet bug betyr insekt, og grunnen til at dette ordet brukes er at i gamle dager var det faktisk et problem at insekter fl√∏y inn i datamaskiner og √∏dela programmer!\n\nProblemet med programmet v√•rt er ikke helt lett √• finne, men siden programmet alltid sier at svaret v√•rt er feil m√• det bety at svar aldri er helt lik tall1 * tall2. Igjen er problemet at Python mener at tekst og tall er forskjellige ting.\n\nN√•r vi bruker input til √• lese inn svar vil dette alltid v√¶re tekst, selv om vi bare skriver inn tall. P√• samme m√•te som vi kan bruke str for √• gj√∏re om tall til tekst kan vi bruke int for √• gj√∏re om tekst til tall (husk at int er en forkortelse for integer som betyr heltall).\n\nEndre if-linjen i programmet ditt til:\n\nif int(svar) == tall1 * tall2:\n\nVirker programmet bedre n√•?\n\n","type":"content","url":"/mattespill-kidsakoder#bug","position":11},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 4: Telle riktige svar"},"type":"lvl2","url":"/mattespill-kidsakoder#steg-4-telle-riktige-svar","position":12},{"hierarchy":{"lvl1":"Mattespill - fra kidsakoder.no","lvl2":"Steg 4: Telle riktige svar"},"content":"\n\nDet er litt kjedelig √• alltid starte programmet p√• nytt. La oss pr√∏ve √• stille flere mattestykker etter hverandre.\n\nHvordan kan vi lage en l√∏kke slik at programmet stiller oss for eksempel 5 mattestykker p√• rad f√∏r det avsluttes? Pr√∏v litt selv i det forrige kodevinduet f√∏r du g√•r videre.\n\nTil slutt vil vi at programmet ogs√• skal telle hvor mange riktige svar vi klarer. For √• gj√∏re dette skal vi bruke en variabel som vi for eksempel kan kalle ant_rett. N√•r vi begynner spillet passer vi p√• at denne er 0 siden vi ikke har svart noenting enda. Hver gang vi svarer riktig kan vi s√• √∏ke verdien av variabelen med 1. Om vi ogs√• legger til en melding til slutt om hvor mange riktige svar spilleren klarte vil programmet se omtrent ut som f√∏lger:\n\nimport random\n\nant_stykker = 5\nant_rett = 0\n\nfor i in range(ant_stykker):\n    svar = random.randint(2, 12)\n    tall = random.randint(2, 12)\n    produkt = svar * tall\n\n    print('Hva er ' + str(produkt) + ' delt p√• ' + str(tall) + '?')\n    svar = input()\n\n    if float(svar) == produkt / tall:\n        print('Ja, svaret er ' + svar)\n        ant_rett = ant_rett + 1\n    else:\n        print('Nei, det riktige svaret er ' + str(produkt / tall))\n\nprint('Du fikk ' + str(ant_rett) + ' av ' + str(ant_stykker))\n\nI programmet over kan du endre p√• antall regnestykker og hvilken regneoperasjon du vil trene. Hva skjer hvis du pr√∏ver √• gj√∏re spillet om til et delespill?","type":"content","url":"/mattespill-kidsakoder#steg-4-telle-riktige-svar","position":13},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python"},"type":"lvl1","url":"/programmering-i-python-del-2","position":0},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python"},"content":"Av Sigurd Rage, Universitetet i S√∏r√∏st-Norge\n\n","type":"content","url":"/programmering-i-python-del-2","position":1},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Arrayer og tabeller"},"type":"lvl2","url":"/programmering-i-python-del-2#arrayer-og-tabeller","position":2},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Arrayer og tabeller"},"content":"\n\nI tillegg til de vanlige datatypene vi allerede har snakket om har Pyton ogs√• mulighet for √• huske flere verdier en og samme variabeltype. Python har innebygget 3 forskjellige typer for dette, lister, tupler og dictionaries. Vi skal her kun se p√• den f√∏rste typen:\n\n# Deklarasjon av liste uten innhold\ntomListe = []\n\n# liste med floats\nlisteDesimaltall = [3.3, 4.2, -8.0, 1.6]\n#liste med forskjellige datatyper\nlisteMix = [\"Ole\", 101, True, -4.89]\n\nprint(listeDesimaltall)\nprint(listeMix)\n\nSom dere ser av eksemplet kan en liste best√• av ingen, en eller flere elementer. Siden Python ikke er kresent p√• datatyper s√• kan en liste best√• av hvilken som helst av disse og til og med forskjellige datatyper i samme liste. Dette er ikke vanlig i andre programmeringsspr√•k. For √• skrive ut ett element fra listen brukes skrivem√•ten minListe[posisjon]. Legg merke til at referansen til f√∏rste element starter p√• 0 og ikke 1.\n\nDet g√•r ogs√• an √• skrive ut deler av listen p√• en enkel m√•te. Grensene angis slik: minListe[a:b]. Dersom du ikke angir start eller slutt vil Python anta at du vil ha med alt fra begynnelsen eller alt frem til slutten av listen. Se f√∏lgende eksempel:\n\nminListe = [\"Ole\", \"Thomas\", \"Kari\", \"Ali\", \"Miriam\", \"Martine\", \"Jonas\", \"Vilde\"]\n\nprint(minListe[2:4])\nprint(minListe[:3])\nprint(minListe[4:])\n\nDet finnes mange funksjoner som h√∏rer til datatypen lister, og vi skal ikke g√• igjennom alle sammen her. Men som eksempler p√• nyttige funksjoner skal vi se p√• hvordan man kan legge til og fjerne elementer, samt sortere lister. Se eksempelet under:\n\nminListe = [\"Ole\", \"Thomas\", \"Kari\", \"Ali\", \"Miriam\", \"Martine\", \"Jonas\", \"Vilde\"]\nprint(minListe)\n\n# Legger til element p√• slutten av listen\nminListe.append(\"Hermann\")\nprint(minListe)\n\n# Fjerner et objekt fra listen\nminListe.remove(\"Kari\")\nprint(minListe)\n\n# Fjerner element fra listen basert p√• ideks, og sparer i en variabel (popping)\nnavn = minListe.pop(1)\nprint(navn)\nprint(minListe)\n\n# Sorterer listen alfabetisk\nminListe.sort()\nprint(minListe)\n\nAppend legger til et element p√• slutten av listen.\n\nRemove trekker fra bestemte objekter i lista. Hvis flere elementer er likes√• fjernes alle.\n\nPop henter ut et element fra listen og returnerer elementet slik at det kan for eksempel skrives ut eller legges i en annen variabel. Dersom pop kalles uten indeks (for eksempel: minListe.pop() ), vil den hente ut det siste elementet i listen.\n\n","type":"content","url":"/programmering-i-python-del-2#arrayer-og-tabeller","position":3},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Iterasjon av lister","lvl2":"Arrayer og tabeller"},"type":"lvl3","url":"/programmering-i-python-del-2#iterasjon-av-lister","position":4},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Iterasjon av lister","lvl2":"Arrayer og tabeller"},"content":"\n\n√Ö iterere en liste betyr √• ¬´bla igjennom lista¬ª, gjerne i en for-sl√∏yfe. I mange kodespr√•k gj√∏res dette p√• den f√∏rste m√•ten som vist i eksempelet over ved at man lager en teller (index) som teller fra 0 og til antall elementer i listen, og henter ut elementene ved hjelp av denne indeksen.\n\nEn mer snedig m√•te √• gj√∏re dette p√• er vist i den nederste metoden: Her skj√∏nner pyton at den skal g√• igjennom listen, men i stedet for √• bruke en tallindeks, henter python automatisk hvert element in i sl√∏yfevariablen direkte.\n\nminListe = [\"Ole\", \"Thomas\", \"Kari\", \"Ali\", \"Miriam\", \"Martine\", \"Jonas\", \"Vilde\"]\n\n# Iterasjon med index, len() gir lengden p√• lista\nfor index in range(len(minListe)):\n    print(minListe[index])\n\n# for mellomrom i utskrift\nprint(\"\")\n\n# Iterasjon med elementmetode (snedig)\nfor element in minListe:\n    print(element)\n\n\n","type":"content","url":"/programmering-i-python-del-2#iterasjon-av-lister","position":5},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Arrayer","lvl2":"Arrayer og tabeller"},"type":"lvl3","url":"/programmering-i-python-del-2#arrayer","position":6},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Arrayer","lvl2":"Arrayer og tabeller"},"content":"\n\nEn array er en form for liste hvor alle elementene er av samme datatype. Et array kan v√¶re endimensjonalt, som en vanlig liste, men kan ogs√• ha flere dimensjoner. For eksempel vil en tabell kunne representeres ved hjelp av en 2-dimensjonal liste. Python har ikke denne datatypen innebygget, men slike finnes i mange standardbiblioteker vi kan benytte oss av. Et vanlig og bra bibliotek til matematikk heter numpy. Dette biblioteker inneholder ogs√• ferdigkompilerte rutiner skrevet i C som gj√∏r at det kan gj√∏re beregninger med og behandle store datamengder p√• relativt kort tid.\n\nEt array kan lages manuelt, og inneholde forskjellige datatyper akkurat som den innebygde typen liste i python. Men vi skal heller konsentrere oss om hvordan vi kan bruke disse til √• lage funksjonstabeller og matematiske analyser\n\nFunksjonen linspace lager en array hvor du kan bestemme start og sluttverdi, og hvor mange elementer du vil ha med i arrayet. Dette er nyttig n√•r man for eksempel skal lage en tabell med x-verdier. Se p√• f√∏lgende eksempel.\n\nimport numpy as np\n\nx_array = np.linspace(-2, 6, 9)\nprint(x_array)\n\nMan kan lage slike linspaces (linear spaces) med s√• mange elementer du vil for bedre oppl√∏sning under beregninger, plotting og s√• videre. Hvis jeg vil ha 50 x-verdier mellom -3 til +8 skriver jeg kommandoen slik:\n\nimport numpy as np\n\nx_array = np.linspace(-3, 8, 50)\nprint(x_array)\n\nHvis jeg n√• vil gj√∏re beregninger p√• x-tabellen min gj√∏res det superenkelt og superraskt ved hjelp av de vanlige regneartene i python. Hvis jeg vil ha en funksjonstabell over f-verdiene til funksjonen: f(x) = x^2 - 4\n\nimport numpy as np\n\nx = np.linspace(-3, 8, 50)\ny = x**2 - 4\n\nprint(y)\n\nDet er imidlertid en ting du ikke kan gj√∏re med arrays fra numpy-biblioteket, og det er √• bruke matematikkfunksjoner fra andre biblioteker p√• arrays. Du kan for eksempel ikke bruke kvadratrot eller trigonometriske funksjoner fra math-biblioteket, da m√• du bruke de funksjonene som er inkludert i numpy slik:\n\nimport numpy as np\n\nx = np.linspace(-3, 8, 50)\ny = np.sin(x)\n\nprint(y)\n\nGrunnen til dette er at math-biblioteket kun kan operere med et og ett element om gangen, mens numpy-biblioteket skj√∏nner at operasjonen skal gj√∏res p√• hvert eneste elemen i arrayet for seg. (Dette kalles for elementvis operasjon)\n\n","type":"content","url":"/programmering-i-python-del-2#arrayer","position":7},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Iterasjon av Arrays","lvl2":"Arrayer og tabeller"},"type":"lvl3","url":"/programmering-i-python-del-2#iterasjon-av-arrays","position":8},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Iterasjon av Arrays","lvl2":"Arrayer og tabeller"},"content":"\n\nIterasjon av arrays er helt likt som for lister. F√∏lgende eksempel itererer et array som heter x, og regner riemannsummen under funksjonsverdien. Verdien til elementene hentes ut med x[i], der i er elementnummeret som telles opp i for-sl√∏yfa:\n\nminArray = np.linspace(-3, 3, 7)\nfor i in range(minArray.size):\n    print(minArray[i])\n\nDet g√•r ogs√• an √• bruke ¬´elementmetoden¬ª p√• arrays.\n\nminArray = np.linspace(-3, 3, 7)\nfor element in minArray:\n    print(element)\n\n","type":"content","url":"/programmering-i-python-del-2#iterasjon-av-arrays","position":9},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Plotting"},"type":"lvl2","url":"/programmering-i-python-del-2#plotting","position":10},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Plotting"},"content":"\n\nI forrige seksjon brukte vi print til √• se p√• verdiene i listene og arrayene v√•re. Det g√•r selvf√∏lgelig an √• plotte grafer fra disse tabellverdiene. Det finnes mange biblioteker som kan tilby dette, men vi skal konsentrere oss om funksjonen plot fra biblioteket matplotlib. Dette er et stort bibliotek med mange undergrupper ‚Äì derfor skal vi ikke importere hele biblioteket, s√• legg merke til hvordan vi importerer her. (Mer om importmetoder lenger ned i dokumentet!)\n\nFor √• lage et enkelt plot lager jeg en x og en y-tabell f√∏rst, og sender disse som argumenter inn i plottefunksjonen. Her er ogs√• kode for √• sette navn p√• aksene. Flere funksjoner i dette biblioteket kan du finne online. I dette eksempelet vil jeg plotte grafen til funksjonen f(x)=-x^3-3x^2+2x-2\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Lager x-verditabell\nx = np.linspace(-10, 10, 100)\ny = -x**3-3*x**2+2*x-2\n\n# Plotter y mot x og setter p√• aksenavn\nplt.xlabel(\"x-akse\")\nplt.ylabel(\"y-akse\")\nplt.plot(x,y)\n\n","type":"content","url":"/programmering-i-python-del-2#plotting","position":11},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Funksjoner"},"type":"lvl2","url":"/programmering-i-python-del-2#funksjoner","position":12},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Funksjoner"},"content":"\n\nFunksjoner i programmering er ikke det helt samme som funksjoner i matematikk, men de har noen likheter. I programmering er funksjoner ferdiglagede kodesnutter som skal brukes flere ganger. Du har allerede brukt mange forskjellige funksjoner i de kodesnuttene som er beskrevet over i dokumentet.\n\nI turtle-biblioteket var det f.eks funksjonen forward(), left(), right() som fikk skilpadden til √• bevege seg. Du har mange ganger brukt den innebyggede funksjonen print() for √• skrive verdier til konsoll. Vi har ogs√• sett p√• matematiske funksjoner, som sin() og sqrt() og i forrige seksjon s√• vi p√• funksjonen plot() som kunne skrive ut grafer.\nDu kan ogs√• lage dine egne funksjoner i python. Funksjoner kan ta s√•kalt input (en eller flere) og den kan returnere output (en eller flere), men de m√• ikke. Dette kalles parameteroverf√∏ring, og vi sier at en funksjon tar ingen, en eller flere parameter inn. Variabler som er laget inni en funksjon er s√•kalt ¬´lokale¬ª, dvs de eksisterer kun inne i funksjonen. Man kan heller ikke endre p√• variabler fra ¬´utsiden¬ª inne i funksjoner. Dette er fordi en funksjon ikke skal lage kr√∏ll p√• dine variabler eller variabler i andre funksjoner.\n\nNedenfor er det 3 eksempler p√• funksjoner. Legg merke til at vi gjenbruker a og b som variabler, det er helt ok siden de kun eksisterer inne i hver sin funksjon.\n\n# Funksjonsdefinisjoner skal st√• √∏verst i pythonkoden ( i det minste f√∏r den kalles og kj√∏res )\n\n# en funksjon uten argumenter (parametere) hverken input eller output\ndef funksjonUten():\n    print(\"Denne funksjonen skriver bare ut dette\")\n    \n# en funksjon med 2 input og ingen output\ndef leggSammen(a,b):\n    print(\"Svaret er:\",a,\"+\",b,\"=\", a+b)\n    \n# en funksjon med 2 input og en output\ndef multipliser(a,b):\n    svartekst = \"Svaret er: \"+str(a)+\" * \"+str(b)+\" = \"+str(a*b)\n    return svartekst\n\n# Kaller funksjonene:\n\n# f√∏rste funksjone er bare en sekvens\nfunksjonUten()\n\n# den andre funksjonen tar forskjellige parameter inn, men skriver ut svaret fra inne i funksjonen\nleggSammen(2,5)\nleggSammen(-3,2)\n\n# den tredje funksjonen returnerer svaret slik at vi kan spare den i v√•r egen variabel\nsvar = multipliser(3,4)\nprint(svar)\n# eller bruke den direkte som input i en annen funksjon (snedig)\nprint(multipliser(-5,6))\n\n","type":"content","url":"/programmering-i-python-del-2#funksjoner","position":13},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Hvordan bruke funksjoner i matematisk sammenheng","lvl2":"Funksjoner"},"type":"lvl3","url":"/programmering-i-python-del-2#hvordan-bruke-funksjoner-i-matematisk-sammenheng","position":14},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Hvordan bruke funksjoner i matematisk sammenheng","lvl2":"Funksjoner"},"content":"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# definerer funksjonene\ndef f(x):\n    return x**2-4\n\ndef g(x):\n    return -np.sin(x)\n\n# Lager x-verditabell\nx = np.linspace(-4, 4, 100)\n\n# Plotter y mot x og setter p√• aksenavn\nplt.xlabel(\"x-akse\")\nplt.ylabel(\"y-akse\")\n# siden funksjonen returnerer y-tabell kan jeg bruke funksjonskallet direkte i plot()\nplt.plot(x,f(x))\nplt.plot(x,g(x))\n\n","type":"content","url":"/programmering-i-python-del-2#hvordan-bruke-funksjoner-i-matematisk-sammenheng","position":15},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Biblioteker"},"type":"lvl2","url":"/programmering-i-python-del-2#biblioteker","position":16},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl2":"Biblioteker"},"content":"\n\nPython er et programmeringsspr√•k under utvikling, selv om struktur og basiskommandoer er uendret kan det hende at det kommer nye konvensjoner p√• hvordan ting skal gj√∏res. Derfor kan det hende at man i noen kodeeksempler ser at ting blir gjort p√• √©n m√•te, mens i andre eksempler en annen. I skrivende stund er Python i versjon 3, som kom i 2008. Likevel er det vanlig √• finne eksempler som er skrevet i versjon 2.7. Disse eksemplene kj√∏rer fint i Python 3, men det hender at du vil f√• en advarsel under kj√∏ring.\n\n","type":"content","url":"/programmering-i-python-del-2#biblioteker","position":17},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"‚ÄúStar imports‚Äù","lvl2":"Biblioteker"},"type":"lvl3","url":"/programmering-i-python-del-2#star-imports","position":18},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"‚ÄúStar imports‚Äù","lvl2":"Biblioteker"},"content":"\n\nDet er spesielt en ting man skal legge merke til. N√•r det gjelder importering av biblioteker vil man n√•, i de fleste utviklingsmilj√∏er (f. eks Spyder) f√• advarsel hvis man pr√∏ver √• importere hele biblioteker uten √• gi de et lokalt navn. Se eksempelet under:\n\nfrom math import *\nfrom numpy import *\n\nsvar = sin(2*pi)\nprint(svar)\n\nHer er bibliotekene math og numpy importert p√• den gamle m√•ten med alle sine respektive funksjoner. Det betyr at hvis disse bibliotekene inneholder en funksjon eller en konstant med samme navn, s√• vet ikke Python hvilken som skal kj√∏res. Og begge disse matematikkbibliotekene inneholder hver sin utgave av funksjonen sin() og pi. I den 3. instruksen her, svar = sin(2*pi), velger sannsynligvis Python fra det biblioteket som ble importert f√∏rst. Akkurat her har det ikke noe √• si for resultatet, men det er ikke alltid sikkert.\n\n","type":"content","url":"/programmering-i-python-del-2#star-imports","position":19},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Import-metoden","lvl2":"Biblioteker"},"type":"lvl3","url":"/programmering-i-python-del-2#import-metoden","position":20},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Import-metoden","lvl2":"Biblioteker"},"content":"\n\nEn mye bedre m√•te √• importere biblioteker p√• er √• bruke denne metoden:\n\nimport math\nimport numpy\n\nsvar = math.sin(2*numpy.pi)\nprint(svar)\n\nHer blir bibliotekenes funksjoner importer under sitt eget navn. N√•r man da skal kalle funksjoner eller bruke konstanter fra bibliotekene s√• angir man dette med biblioteksnavnet som prefiks slik: biblioteksnavn.funksjonsnavn() eller konstantnavn. P√• denne m√•ten kan vi importere biblioteker som inneholder funksjoner med samme navn uten at det blir problemer av det. I eksempelet over brukes sinusfunksjonen fra math, og konstanten pi fra numpy\n\n","type":"content","url":"/programmering-i-python-del-2#import-metoden","position":21},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Alias-metoden","lvl2":"Biblioteker"},"type":"lvl3","url":"/programmering-i-python-del-2#alias-metoden","position":22},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Alias-metoden","lvl2":"Biblioteker"},"content":"\n\nMan kan ogs√• importere biblioteker og gi de et lokalt alias. Denne metoden er ofte brukt for √• lage forkortelser, eller hvis man skal importere et underbibliotek\n\nimport math as m\nimport numpy as np\n\nsvar = np.sin(2*m.pi)\nprint(svar)\n\nHer er bibliotekene math og numpy importert slik at de f√•r de lokale aliasene m og np. Man kan selv velge hvilket alias som skal brukes lokalt, men det er lurt √• velge et navn slik at man husker hva det refererer til. Hvis man vil bruke sin() fra numpy, s√• skriver man np.sin(). I eksempelet over henter vi sin() fra numpy og konstanten pi fra math. (Motsatt av forrige eksempel!)\n\n","type":"content","url":"/programmering-i-python-del-2#alias-metoden","position":23},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Importere del av et bibliotek","lvl2":"Biblioteker"},"type":"lvl3","url":"/programmering-i-python-del-2#importere-del-av-et-bibliotek","position":24},{"hierarchy":{"lvl1":"Funksjoner og plotting i Python","lvl3":"Importere del av et bibliotek","lvl2":"Biblioteker"},"content":"\n\nNoen ganger vil man ikke importere hele biblioteker, da kan man importere bare den biten man √∏nsker seg. I eksempelet under vil vi importere en plottefunksjon fra mathplotlib, som er et ganske omfattende bibliotek.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(-4,4,100)\ny = x**2-4\n\nplt.plot(x,y)\n\nKoden over importerer kun underbiblioteket pyplot og vi gir det det lokale aliaset plt, som n√• refererer direkte til dette.","type":"content","url":"/programmering-i-python-del-2#importere-del-av-et-bibliotek","position":25},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning"},"type":"lvl1","url":"/simulering-av-radioaktiv-nedbrytning","position":0},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning"},"content":"Av Sigurd Rage - USN\n\n\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning","position":1},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Introduksjon"},"type":"lvl2","url":"/simulering-av-radioaktiv-nedbrytning#introduksjon","position":2},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Introduksjon"},"content":"I denne aktiviteten ser vi p√• hvordan vi kan simulere radioaktiv nedbrytning med terninger og programmering. Den tar utgangspunkt i et klassisk fors√∏k der elevene bruker terninger for √• simulere radioaktiv nedbrytning, samler data og analyserer resultatene i CAS-verkt√∏y (Geogebra) og vurderer resultatet mot en matematisk modell. Deretter tas problemet videre i en programmeringsoppgave.\n\nAktiviteten passer best for elever p√• 10. trinn og dekker flere aktuelle kompetansem√•l fra b√•de 9. og 10. trinn. Den kan ogs√• fungere som tverrfaglig oppgave med naturfag\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#introduksjon","position":3},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Kompetansem√•l"},"type":"lvl2","url":"/simulering-av-radioaktiv-nedbrytning#kompetansem-l","position":4},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Kompetansem√•l"},"content":"Matematikk 9. trinn\n\nberekne og vurdere sannsyn i statistikk og spel\n\nsimulere utfall i tilfeldige fors√∏k og berekne sannsynet for at noko skal inntreffe, ved √• bruke programmering\n\nMatematikk 10. trinn\n\nbruke funksjonar i modellering og argumentere for framgangsm√•tar og resultat\n\nmodellere situasjonar knytte til reelle datasett, presentere resultata og argumentere for at modellane er gyldige\n\nutforske matematiske eigenskapar og samanhengar ved √• bruke programmering\n\nutforske samanhengen mellom konstant prosentvis endring, vekstfaktor og eksponentialfunksjonar\n\nutforske og samanlikne eigenskapar ved ulike funksjonar ved √• bruke digitale verkt√∏y\n\nNaturfag 10. trinn\n\nbruke programmering til √• utforske naturfaglige fenomener\n\nbruke og lage modeller for √• forutsi eller beskrive naturfaglige prosesser og systemer og gj√∏re rede for modellenes styrker og begrensninger\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#kompetansem-l","position":5},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Analog aktivitet"},"type":"lvl2","url":"/simulering-av-radioaktiv-nedbrytning#analog-aktivitet","position":6},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Analog aktivitet"},"content":"\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#analog-aktivitet","position":7},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Arbeid med teoretisk modell","lvl2":"Analog aktivitet"},"type":"lvl3","url":"/simulering-av-radioaktiv-nedbrytning#arbeid-med-teoretisk-modell","position":8},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Arbeid med teoretisk modell","lvl2":"Analog aktivitet"},"content":"Elevene jobber seg fram til en modell for fors√∏ket. Siden sannsynligheten for √• f√• en sekser p√• terningen er  P = \\frac{1}{6}  vil de kunne resonnere seg frem til at sannsynligvis kan  \\frac{1}{6}  av terningene fjernes for hver runde. En mulig modell for fors√∏ket kan da v√¶re eksponentialfunksjonen M(x) = M_0 \\cdot \\frac{5}{6}^x\n\n der  M_0  er mengden terninger ved start.\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#arbeid-med-teoretisk-modell","position":9},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Aktivitet med terninger","lvl2":"Analog aktivitet"},"type":"lvl3","url":"/simulering-av-radioaktiv-nedbrytning#aktivitet-med-terninger","position":10},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Aktivitet med terninger","lvl2":"Analog aktivitet"},"content":"Elevene deles i grupper og f√•r utdelt et terningssett hver. Dess flere terninger dess bedre, vi hadde 165 terninger i v√•r gjennomf√∏ring. Elevene kaster terningene i runder og fjerner alle terningene som viser 6, og noterer hvor mange terninger de har igjen etter hver runde. Etter 10 runder oppsummeres gruppenes resultater i plenum og vi regner ut totalen for hver runde\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#aktivitet-med-terninger","position":11},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Oppsummering og analyse","lvl2":"Analog aktivitet"},"type":"lvl3","url":"/simulering-av-radioaktiv-nedbrytning#oppsummering-og-analyse","position":12},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl3":"Oppsummering og analyse","lvl2":"Analog aktivitet"},"content":"\n\n\n\nResultatene legges inn i graftegner og kan analyseres visuelt\n\n\n\nI neste plott har vi brukt regresjon (RegEksp) og f√•tt en regresjonskurve med funksjonen  M = 215.7 \\cdot 0.74^x  i gr√∏nt.\nI tillegg har vi lagt inn den teoretiske sannsynlighetsmodellen  M = 165 \\cdot \\frac{5}{6}^x \n\n\n\nHer ser vi at regresjonsfunksjonen ikke likner p√• den teoretiske modellen, ei heller passer dataene s√¶rlig bra inn, s√• hva har skjedd?\n\nDette er en fin anledning til at elevene f√•r diskutere.\n\n","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#oppsummering-og-analyse","position":13},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Programmering av simulasjonen"},"type":"lvl2","url":"/simulering-av-radioaktiv-nedbrytning#programmering-av-simulasjonen","position":14},{"hierarchy":{"lvl1":"Simulering av radioaktiv nedbrytning","lvl2":"Programmering av simulasjonen"},"content":"Her skal det komme en mer steg-for-steg progresjon for elevene (PRIMM). Nedenfor er forslag til ferdig kode som har samme startparametere som det analoge fors√∏ket med terninger. Ved √• kj√∏re flere ganger vil man legge merke til at simulasjonen ligger n√¶rmere teoretisk modell dess flere ‚Äúterninger‚Äù som er igjen i mengden (alts√• i starten av fors√∏ket). N√•r restmengden blir lavere s√• varierer resulatet mer. Dette kan kobles til store talls lov. Vi arbeider tross alt med et stokastisk fors√∏k i denne simuleringen, og da vil variasjon i utfall f√• mer √• si.\n\nN√•r dette er belyst kan man heller leke seg litt med programmet, og √∏ke mengden (165 terninger skal simulere et gram uran som inneholder XXX antall kjerner?). Man kan ogs√• leke litt med √• √∏ke antall iterasjoner (runder).\n\n\"\"\"\nSimulering av decay (feks nedbrytning av radioaktivt materiale)\n\nCreated on Wed Jan 15 10:26:58 2025\n\n@author: Sigurd Rage @ University of Southeastern Norway\n\"\"\"\nimport random as rnd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Antall kjerner ved start\nM = 165\n\n# Sannsynlighet for endring av materie\np = 1/6\n\n# antall iterasjoner (sekunder, √•r?)\nN = 10\n\n# tabell for √• huske antall restmengde pr iterasjon, og legger til startmengden\ntabell = []\ntabell.append(M)\n\n# ytre sl√∏yfe pr iterasjon\nfor i in range(N):\n    count = 0\n    # indre sl√∏yfe simulerer decay per element i mengden\n    for j in range(M):\n        if rnd.random() <= p:\n            count += 1 # teller antall elementer som endres\n    # trekker fra elementene som har endret seg og oppdaterer tabellen\n    M -= count\n    tabell.append(M)\n\n# lager en x og y-tabell for iterasjon og restmengde (kan skaleres til tid)\nx = np.linspace(0, len(tabell)-1, len(tabell))\ny = np.array(tabell)\n\nfasit_y = y[0]*(1-p)**x\n\n\n# plotter resultatet og setter y-aksen slik at den alltid viser 0\nf, ax = plt.subplots(1)\nax.plot(x, y, \"bo\")\nax.plot(x, fasit_y, \"r\")\nax.set_ylim(ymin=0)\nplt.show(f)","type":"content","url":"/simulering-av-radioaktiv-nedbrytning#programmering-av-simulasjonen","position":15},{"hierarchy":{"lvl1":"Fors√∏k med mange terninger - normalfordeling"},"type":"lvl1","url":"/forsok-med-sum-av-flere-terninger","position":0},{"hierarchy":{"lvl1":"Fors√∏k med mange terninger - normalfordeling"},"content":"Ved f√∏rste kj√∏ring m√• det installeres noen biblioteker. Det tar litt tid, s√• v√¶r t√•lmodig\n\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Feb 28 00:53:24 2022\n\n@author: sigur\n\"\"\"\n\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# setter opp terning og antall kast. Endre p√• disse parameterene!\nsider = 6\nantall_terninger = 5\nantall_forsok = 100000\n\n# Regner ut antall mulige utfall, fra minste mulige verdi til st√∏rste mulige verdi)\nantall_mulige_utfall = antall_terninger * sider - (antall_terninger-1)\n\n# Tabell for √• registrere antall forekomster av hvert fors√∏k\nfordeling = np.zeros(antall_mulige_utfall)\n\n# kaster terningen, husker sum og antall forekomster\nfor i in range (antall_forsok):\n    sum=0\n    \n    for j in range(antall_terninger):\n        sum += random.randint(1, sider)\n    \n    fordeling[sum-antall_terninger]+=1\n\nprint(\"Antall terninger: \" + str(antall_terninger))\nprint(\"Antall fors√∏k: \" + str(antall_forsok))\n    \n# Lager et s√∏ylediagram over relativ frekvens for alle fors√∏kene\nrelativ_frekvens = fordeling/antall_forsok\nakse = np.linspace(antall_terninger, antall_mulige_utfall+antall_terninger-1, antall_mulige_utfall)\n\nfig = plt.figure()\nax = fig.add_axes([0,0,1,1])\nax.bar(akse,relativ_frekvens)\nplt.title(\"Relativ frekvens for summen av \" + str(antall_terninger) + \" terninger, ved \" + str(antall_forsok) + \" fors√∏k\" )\nplt.xlabel(\"sum\")\nplt.ylabel(\"relativ frekvens\")\nplt.show()","type":"content","url":"/forsok-med-sum-av-flere-terninger","position":1},{"hierarchy":{"lvl1":"Naturfag - introduksjon"},"type":"lvl1","url":"/naturfag-oversikt","position":0},{"hierarchy":{"lvl1":"Naturfag - introduksjon"},"content":"Her er en oversikt over undersidene i seksjonen naturfag","type":"content","url":"/naturfag-oversikt","position":1},{"hierarchy":{"lvl1":"Automatisk potteplantevanning"},"type":"lvl1","url":"/microbit-automatisk-vanning","position":0},{"hierarchy":{"lvl1":"Automatisk potteplantevanning"},"content":"Av Sigurd Rage - Universitetet i S√∏r√∏st-Norge\n\n\n\n","type":"content","url":"/microbit-automatisk-vanning","position":1},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Introduksjon"},"type":"lvl2","url":"/microbit-automatisk-vanning#introduksjon","position":2},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Introduksjon"},"content":"I denne aktiviteten skal vi se p√• hvordan vi kan bruke en microbit til √• styre en vannpumpe basert p√• sensordata fra en jordfuktsensor. F√∏rst kommer en beskrivelse av et nesten ferdig system med fuktsensor og pumpe koblet ferdig koblet til microbiten, deretter kommer et forslag til hvordan dette prosjektet kan gjennomf√∏res i klasserommet. Prosjektet krever at man har tilgang p√• et ‚Äúbreakout board‚Äù for microbit, ellers er det utstyret som kreves hyllevare og relativt billig i anskaffelse.\n\nHele prosjektet, med halvferdig kode kan lastes ned her:\n\nhttps://‚Äãwww‚Äã.tinkercad‚Äã.com‚Äã/things‚Äã/0w034yFNd52‚Äã?sharecode‚Äã=‚ÄãQMJCpwQsSBU0375orkOx1ITjqXw1VgHsDG9D1CzmHjE\n\n","type":"content","url":"/microbit-automatisk-vanning#introduksjon","position":3},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Kompetansem√•l (LK2020)"},"type":"lvl2","url":"/microbit-automatisk-vanning#kompetansem-l-lk2020","position":4},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Kompetansem√•l (LK2020)"},"content":"designe og lage et produkt basert p√• en kravspesifikasjon (4. trinn)\n\nutforske teknologiske systemer som er satt sammen av ulike deler, og beskrive hvordan delene fungerer og virker sammen (4. trinn)\n\ndesigne og lage et produkt basert p√• brukerbehov (7. trinn)\n\nutforske, lage og programmere teknologiske systemer som best√•r av deler som virker sammen (7. trinn)\n\nbruke programmering til √• utforske naturfaglige fenomener (10. trinn)\n\nAktiviteten passer nok best for elever fra 7. trinn og oppover som er vant til √• bruke tilleggssutstyr til microbit, feks TinkerKit eller tilsvarende. Det er ogs√• et opplegg som kan kobles til elektrisitets- og kretsl√¶re.\n\n","type":"content","url":"/microbit-automatisk-vanning#kompetansem-l-lk2020","position":5},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Utstyrsliste"},"type":"lvl2","url":"/microbit-automatisk-vanning#utstyrsliste","position":6},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Utstyrsliste"},"content":"Microbit (V1 eller V2)\n\nBreakout board\n\nKoblingsbrett\n\nJordfuktsensor (resistiv type)\n\nMotstand 2.2 kŒ©\n\nTransistor NPN (feks BC377)\n\nVannpumpe (3 ‚Äì 5V)\n\nEksperimentkabler\n\nKrokodillekabler\n\nSlange til vannpumpe\n\nVanntank\n\nPotteplante\n\n","type":"content","url":"/microbit-automatisk-vanning#utstyrsliste","position":7},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Koblingsskjema og komponenter"},"type":"lvl2","url":"/microbit-automatisk-vanning#koblingsskjema-og-komponenter","position":8},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Koblingsskjema og komponenter"},"content":"\n\n\n\nI dette skjemaet er jordfuktssensoren koblet til P0 og pumpestyringen koblet til P1. Transistoren virker som en bryter for pumpestyring, og f√•r styringssignalet fra P1. Mellom P1 og transistoren ligger en motstand p√• 2.2kŒ©, da transistoren kun trenger bittelitt str√∏m for √• ‚Äúsl√• inn‚Äù\n\n","type":"content","url":"/microbit-automatisk-vanning#koblingsskjema-og-komponenter","position":9},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Jordfuktsensor","lvl2":"Koblingsskjema og komponenter"},"type":"lvl3","url":"/microbit-automatisk-vanning#jordfuktsensor","position":10},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Jordfuktsensor","lvl2":"Koblingsskjema og komponenter"},"content":"\n\nI dette prosjektet brukes en s√•kalt resistiv jordfuktssensor, som er den enkleste og billigste typen. Denne sensoren har normalt 3 eller 4 koblingspunkter ut fra modulen. VCC kobles til 3V og GND kobles til 0V. AO (analog out) vil gi en spenning inn p√• P0 avhengig av hvor fuktig jorden i potteplanten er. P√• noen sensortyper st√•r det SIG istedet for AO p√• signalpinnen (se kretstegning)\n\nNoen slike sensorer har ogs√• en DO (digital out), denne skal ikke brukes.\n\nSensoren m√•ler elektrisk motstand i plantejorda. N√•r jorda blir fuktig vil den lede mer str√∏m mellom elektrodene enn hvis den er t√∏rr. Typisk vil spenningen fra AO v√¶re h√∏yere ved t√∏rr jord og lavere ved fuktig jord. Denne spenningsverdien blir avlest som en digital heltallsverdi av microbit, som vi kan bruke i styringsprogrammet til √• ta en avgj√∏relse om potteplanten trenger vanning. For √• en fornuftig terskelverdi for vanning b√∏r man teste denne sensoren i jord.\n\nEn svakhet med denne typer sensorer er at de korroderer i fuktig milj√∏, som gir de en noe kort levetid. Det finnes ogs√• kapasitive jordfuktsensorer, som koster noe mer og har litt mer komplisert tilkobling.\n\n","type":"content","url":"/microbit-automatisk-vanning#jordfuktsensor","position":11},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Vannpumpe","lvl2":"Koblingsskjema og komponenter"},"type":"lvl3","url":"/microbit-automatisk-vanning#vannpumpe","position":12},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Vannpumpe","lvl2":"Koblingsskjema og komponenter"},"content":"\n\nDette er en vannpumpe som drives av en DC-motor (likestr√∏msmotor) som krever mellom 3 og 5V. Pumpemotoren trekker en god del str√∏m, og kan derfor ikke styres direkte fra pinnene til microbiten. Istedet kobles motoren rett p√• microbitens innebygde str√∏mkilde, pinnene 3V og 0V, men for √• kunne styre den, legger vi en transistor imellom. Da vil transistoren fungere som en elektronisk bryter til pumpen.\n\nMicrobit sine tilkoblingsporter kan maksimalt levere 10mA str√∏m, mens 3V ‚Äì pinnen kan levere 90mA (V1) eller opptil 120mA (V2).\n\nEn annen ting √• ha i bakhodet er at denne pumpen er relativt svak, s√• vannreservoaret b√∏r v√¶re i samme h√∏yde som potteplanten.\n\n","type":"content","url":"/microbit-automatisk-vanning#vannpumpe","position":13},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Transistor","lvl2":"Koblingsskjema og komponenter"},"type":"lvl3","url":"/microbit-automatisk-vanning#transistor","position":14},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl3":"Transistor","lvl2":"Koblingsskjema og komponenter"},"content":"\n\nTransistoren er en av det 20. √•rhundrets st√∏rste oppfinnelser og har muliggjort alle de avanserte digitale enhetene vi omgir oss med til daglig. Det er en halvlederkomponent, og har 3 tilkoblinger: Base, Collector og Emitter. I denne kretsen fungerer transistoren rett og slett som en elektronisk bryter, som kan styre om det skal g√• str√∏m igjennom eller ikke. Base kobles i retning mot +3V og Emitter kobles i retning mot 0V (eller GND). Hvorvidt det g√•r str√∏m gjennom transistoren eller ikke styres av Collector. Det skal sv√¶rt lite str√∏m til p√• Collector for at transistoren leder, derfor kobler vi en relativt stor motstand i serie foran denne terminalen (tilkoblingen). I kretsen under er transistoren satt inn mellom 3V og pumpen. N√•r det ikke g√•r str√∏m inn p√• Base fra P1 vil transistoren sperre for str√∏m til motoren.\n\nDet er fors√•vidt akkurat det samme om transistoren er koblet som vist, eller om den er koblet inn mellom motor og GND\n\n","type":"content","url":"/microbit-automatisk-vanning#transistor","position":15},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Kretsskjema"},"type":"lvl2","url":"/microbit-automatisk-vanning#kretsskjema","position":16},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Kretsskjema"},"content":"\n\n\n\nOver ser vi et mer standardisert kretsskjema for prosjektet. I sammenligning med koblingsskjemaet lenge opp er det mer abstrakt, men selve sammenkoblingen av komponentene er mer tydelig og oversiktlig.\n\n","type":"content","url":"/microbit-automatisk-vanning#kretsskjema","position":17},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Reell oppkobling (kabelspaghetti)"},"type":"lvl2","url":"/microbit-automatisk-vanning#reell-oppkobling-kabelspaghetti","position":18},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Reell oppkobling (kabelspaghetti)"},"content":"\n\n\n\nAlle skjematiske fremstillinger av kretser ser som regel mye ryddigere ut p√• papir enn hvordan den faktiske kretsen blir seendes ut p√• brettet. Hvordan komponentene kobles sammen p√• koblingsbrettet, og hvordan man f√•r koblet de eksterne delene inn p√• kretsen krever noe kunnskap om p√• hvilke m√•ter dette kan gj√∏res. I litteraturen om teknologi i skolen kalles dette for ‚Äúhandlingskunnskap‚Äù.\n\nI dette eksempelet har vi brukt eksperimentkabler, som er ferdig lagde kabler med hann- og hunnterminaler som passer til brettet, samt krokodillekabler for √• koble p√• pumpen.\n\nDet er ogs√• fullt mulig √• koble at sammen kun med krokodillekabler, uten koblingsbrett, da blir kabelsalaten tilsvarende mer rotete üôÇ\n\n","type":"content","url":"/microbit-automatisk-vanning#reell-oppkobling-kabelspaghetti","position":19},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Programmering av styringsenheten"},"type":"lvl2","url":"/microbit-automatisk-vanning#programmering-av-styringsenheten","position":20},{"hierarchy":{"lvl1":"Automatisk potteplantevanning","lvl2":"Programmering av styringsenheten"},"content":"\n\n\n\nProgrammet over kan v√¶re et godt utgangspunkt for styring av pumpen, men den er ikke ferdig. Likevel, et par viktige momenter √• ta med seg:\n\nSensorverdier fra jordfuktsensoren leses som analogverdi fra P0\n\nStyring av pumpen skjer ved √• sette digital verdi p√• P1 til 1 (3V) for √• starte pumpen, og digital verdi P1 til 0 (0V) for √• stoppe den.\n\nI blokken ‚Äúved start‚Äù setter vi styringssignalet til pumpen til LOW, eller 0V for √• v√¶re helt sikre p√• at pumpen ikke starter av seg selv\n\nFor √• kunne lese av den digitale verdien fra jordfuktsensoren har vi en kodeblokk ‚Äún√•r knapp A trykkes‚Äù som skriver denne verdien til skjerm. Dette kan v√¶re nyttig for √• finne ut hva slags verdier som denne sensoren gir fra t√∏rr eller fuktig jord.\n\nSelve pumpestyringen skjer i ‚Äúgjenta for alltid‚Äù-sl√∏yfen. I denne eksempelkoden er grensen for at pumpen skal starte satt til verdien 500, men den reelle grenseverdien m√• finnes ved utpr√∏ving p√• en reell potteplante.\n\nDersom avlest verdi er h√∏yere enn grenseverdien vil if-testen sl√• inn, og pumpen kj√∏res i 5 sekunder. Denne verdien m√• ogs√• finnes ved eksperimentering: hvor mye vann pumpes per tid, og hvor mye vann trenger potteplanten per vanning.\n\nDeretter venter systemet i 1 minutt f√∏r den sjekker fuktigheten i potteplanten p√• nytt. Dette er nok alt for kort tid i en reell situasjon, og systemet trenger kanskje ikke √• sjekke for vanning mer enn et par ganger om dagen. Dessuten trenger potteplanten noe tid for at vannet skal fordeles jevnt i jorden.\n\nAlts√•:\n\nMan m√• finne en reell grenseverdi for jordfuktsensoren slik at vanning kommer p√• √∏nsket t√∏rrhet\n\nMan m√• beregne hvor mye vann som trenges for hver vanning, og hvor lang tid dette tar for pumpen\n\nMan m√• legge inn en generell forsinkelse slik at planten ikke overvannes. Typisk trenger man ikke √• sjekke jordfukten mer enn en gang om dagen.\n\nKoden kan lastes ned fra \n\nmakecode.org her: \n\nhttps://‚Äãmakecode‚Äã.microbit‚Äã.org‚Äã/‚Äã_bfKHo6A08Ecc\n\n a + b = c ","type":"content","url":"/microbit-automatisk-vanning#programmering-av-styringsenheten","position":21}]}